/**
 *
 */

/**
 * Generated by scraping https://en.wikipedia.org/wiki/Java_bytecode_instruction_listings with:
 * `Array.prototype.map.call(trs.children, tr => {
        var ch = Array.prototype.map.call(tr.children, el => el.textContent.trim());
        var res = ''
        res += ch[3] !== '' ? '    // ' + ch[3] + '\n' : '';
        res += '    // ' + ch[4] + '\n';
        res += '    // ' + ch[5] + '\n';
        res += '    const val ' + ch[0] + ' = 0x' + ch[1] + '\n';
        return res;
    }).join('\n')`
 */
// Uncomment this to see which opcodes aren't yet implemented
//@Suppress("Unused")
object Opcodes {
    // arrayref, index → value
    // load onto the stack a reference from an array
    const val aaload = 0x32

    // arrayref, index, value →
    // store into a reference in an array
    const val aastore = 0x53

    // → null
    // push a null reference onto the stack
    const val aconst_null = 0x01

    // 1: index
    // → objectref
    // load a reference onto the stack from a local variable #index
    const val aload = 0x19

    // → objectref
    // load a reference onto the stack from local variable 0
    const val aload_0 = 0x2a

    // → objectref
    // load a reference onto the stack from local variable 1
    const val aload_1 = 0x2b

    // → objectref
    // load a reference onto the stack from local variable 2
    const val aload_2 = 0x2c

    // → objectref
    // load a reference onto the stack from local variable 3
    const val aload_3 = 0x2d

    // 2: indexbyte1, indexbyte2
    // count → arrayref
    // create a new array of references of length count and component type identified by the class reference index
    // (indexbyte1 << 8 + indexbyte2) in the constant pool
    const val anewarray = 0xbd

    // objectref → [empty]
    // return a reference from a method
    const val areturn = 0xb0

    // arrayref → length
    // get the length of an array
    const val arraylength = 0xbe

    // 1: index
    // objectref →
    // store a reference into a local variable #index
    const val astore = 0x3a

    // objectref →
    // store a reference into local variable 0
    const val astore_0 = 0x4b

    // objectref →
    // store a reference into local variable 1
    const val astore_1 = 0x4c

    // objectref →
    // store a reference into local variable 2
    const val astore_2 = 0x4d

    // objectref →
    // store a reference into local variable 3
    const val astore_3 = 0x4e

    // objectref → [empty], objectref
    // throws an error or exception (notice that the rest of the stack is cleared, leaving only a reference to the
    // Throwable)
    const val athrow = 0xbf

    // arrayref, index → value
    // load a byte or Boolean value from an array
    const val baload = 0x33

    // arrayref, index, value →
    // store a byte or Boolean value into an array
    const val bastore = 0x54

    // 1: byte
    // → value
    // push a byte onto the stack as an integer value
    const val bipush = 0x10

    //
    // reserved for breakpoints in Java debuggers; should not appear in any class file
    const val breakpoint = 0xca

    // arrayref, index → value
    // load a char from an array
    const val caload = 0x34

    // arrayref, index, value →
    // store a char into an array
    const val castore = 0x55

    // 2: indexbyte1, indexbyte2
    // objectref → objectref
    // checks whether an objectref is of a certain type, the class reference of which is in the constant pool at index
    // (indexbyte1 << 8 + indexbyte2)
    const val checkcast = 0xc0

    // value → result
    // convert a double to a float
    const val d2f = 0x90

    // value → result
    // convert a double to an int
    const val d2i = 0x8e

    // value → result
    // convert a double to a long
    const val d2l = 0x8f

    // value1, value2 → result
    // add two doubles
    const val dadd = 0x63

    // arrayref, index → value
    // load a double from an array
    const val daload = 0x31

    // arrayref, index, value →
    // store a double into an array
    const val dastore = 0x52

    // value1, value2 → result
    // compare two doubles
    const val dcmpg = 0x98

    // value1, value2 → result
    // compare two doubles
    const val dcmpl = 0x97

    // → 0.0
    // push the constant 0.0 (a double) onto the stack
    const val dconst_0 = 0x0e

    // → 1.0
    // push the constant 1.0 (a double) onto the stack
    const val dconst_1 = 0x0f

    // value1, value2 → result
    // divide two doubles
    const val ddiv = 0x6f

    // 1: index
    // → value
    // load a double value from a local variable #index
    const val dload = 0x18

    // → value
    // load a double from local variable 0
    const val dload_0 = 0x26

    // → value
    // load a double from local variable 1
    const val dload_1 = 0x27

    // → value
    // load a double from local variable 2
    const val dload_2 = 0x28

    // → value
    // load a double from local variable 3
    const val dload_3 = 0x29

    // value1, value2 → result
    // multiply two doubles
    const val dmul = 0x6b

    // value → result
    // negate a double
    const val dneg = 0x77

    // value1, value2 → result
    // get the remainder from a division between two doubles
    const val drem = 0x73

    // value → [empty]
    // return a double from a method
    const val dreturn = 0xaf

    // 1: index
    // value →
    // store a double value into a local variable #index
    const val dstore = 0x39

    // value →
    // store a double into local variable 0
    const val dstore_0 = 0x47

    // value →
    // store a double into local variable 1
    const val dstore_1 = 0x48

    // value →
    // store a double into local variable 2
    const val dstore_2 = 0x49

    // value →
    // store a double into local variable 3
    const val dstore_3 = 0x4a

    // value1, value2 → result
    // subtract a double from another
    const val dsub = 0x67

    // value → value, value
    // duplicate the value on top of the stack
    const val dup = 0x59

    // value2, value1 → value1, value2, value1
    // insert a copy of the top value into the stack two values from the top. value1 and value2 must not be of the type
    // double or long.
    const val dup_x1 = 0x5a

    // value3, value2, value1 → value1, value3, value2, value1
    // insert a copy of the top value into the stack two (if value2 is double or long it takes up the entry of value3,
    // too) or three values (if value2 is neither double nor long) from the top
    const val dup_x2 = 0x5b

    // {value2, value1} → {value2, value1}, {value2, value1}
    // duplicate top two stack words (two values, if value1 is not double nor long; a single value, if value1 is double
    // or long)
    const val dup2 = 0x5c

    // value3, {value2, value1} → {value2, value1}, value3, {value2, value1}
    // duplicate two words and insert beneath third word (see explanation above)
    const val dup2_x1 = 0x5d

    // {value4, value3}, {value2, value1} → {value2, value1}, {value4, value3}, {value2, value1}
    // duplicate two words and insert beneath fourth word
    const val dup2_x2 = 0x5e

    // value → result
    // convert a float to a double
    const val f2d = 0x8d

    // value → result
    // convert a float to an int
    const val f2i = 0x8b

    // value → result
    // convert a float to a long
    const val f2l = 0x8c

    // value1, value2 → result
    // add two floats
    const val fadd = 0x62

    // arrayref, index → value
    // load a float from an array
    const val faload = 0x30

    // arrayref, index, value →
    // store a float in an array
    const val fastore = 0x51

    // value1, value2 → result
    // compare two floats
    const val fcmpg = 0x96

    // value1, value2 → result
    // compare two floats
    const val fcmpl = 0x95

    // → 0.0f
    // push 0.0f on the stack
    const val fconst_0 = 0x0b

    // → 1.0f
    // push 1.0f on the stack
    const val fconst_1 = 0x0c

    // → 2.0f
    // push 2.0f on the stack
    const val fconst_2 = 0x0d

    // value1, value2 → result
    // divide two floats
    const val fdiv = 0x6e

    // 1: index
    // → value
    // load a float value from a local variable #index
    const val fload = 0x17

    // → value
    // load a float value from local variable 0
    const val fload_0 = 0x22

    // → value
    // load a float value from local variable 1
    const val fload_1 = 0x23

    // → value
    // load a float value from local variable 2
    const val fload_2 = 0x24

    // → value
    // load a float value from local variable 3
    const val fload_3 = 0x25

    // value1, value2 → result
    // multiply two floats
    const val fmul = 0x6a

    // value → result
    // negate a float
    const val fneg = 0x76

    // value1, value2 → result
    // get the remainder from a division between two floats
    const val frem = 0x72

    // value → [empty]
    // return a float
    const val freturn = 0xae

    // 1: index
    // value →
    // store a float value into a local variable #index
    const val fstore = 0x38

    // value →
    // store a float value into local variable 0
    const val fstore_0 = 0x43

    // value →
    // store a float value into local variable 1
    const val fstore_1 = 0x44

    // value →
    // store a float value into local variable 2
    const val fstore_2 = 0x45

    // value →
    // store a float value into local variable 3
    const val fstore_3 = 0x46

    // value1, value2 → result
    // subtract two floats
    const val fsub = 0x66

    // 2: indexbyte1, indexbyte2
    // objectref → value
    // get a field value of an object objectref, where the field is identified by field reference in the constant pool
    // index (indexbyte1 << 8 + indexbyte2)
    const val getfield = 0xb4

    // 2: indexbyte1, indexbyte2
    // → value
    // get a static field value of a class, where the field is identified by field reference in the constant pool index
    // (indexbyte1 << 8 + indexbyte2)
    const val getstatic = 0xb2

    // 2: branchbyte1, branchbyte2
    // [no change]
    // goes to another instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 +
    // branchbyte2)
    const val goto = 0xa7

    // 4: branchbyte1, branchbyte2, branchbyte3, branchbyte4
    // [no change]
    // goes to another instruction at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 +
    // branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4)
    const val goto_w = 0xc8

    // value → result
    // convert an int into a byte
    const val i2b = 0x91

    // value → result
    // convert an int into a character
    const val i2c = 0x92

    // value → result
    // convert an int into a double
    const val i2d = 0x87

    // value → result
    // convert an int into a float
    const val i2f = 0x86

    // value → result
    // convert an int into a long
    const val i2l = 0x85

    // value → result
    // convert an int into a short
    const val i2s = 0x93

    // value1, value2 → result
    // add two ints
    const val iadd = 0x60

    // arrayref, index → value
    // load an int from an array
    const val iaload = 0x2e

    // value1, value2 → result
    // perform a bitwise AND on two integers
    const val iand = 0x7e

    // arrayref, index, value →
    // store an int into an array
    const val iastore = 0x4f

    // → -1
    // load the int value −1 onto the stack
    const val iconst_m1 = 0x02

    // → 0
    // load the int value 0 onto the stack
    const val iconst_0 = 0x03

    // → 1
    // load the int value 1 onto the stack
    const val iconst_1 = 0x04

    // → 2
    // load the int value 2 onto the stack
    const val iconst_2 = 0x05

    // → 3
    // load the int value 3 onto the stack
    const val iconst_3 = 0x06

    // → 4
    // load the int value 4 onto the stack
    const val iconst_4 = 0x07

    // → 5
    // load the int value 5 onto the stack
    const val iconst_5 = 0x08

    // value1, value2 → result
    // divide two integers
    const val idiv = 0x6c

    // 2: branchbyte1, branchbyte2
    // value1, value2 →
    // if references are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes
    // branchbyte1 << 8 + branchbyte2)
    const val if_acmpeq = 0xa5

    // 2: branchbyte1, branchbyte2
    // value1, value2 →
    // if references are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes
    // branchbyte1 << 8 + branchbyte2)
    const val if_acmpne = 0xa6

    // 2: branchbyte1, branchbyte2
    // value1, value2 →
    // if ints are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes
    // branchbyte1 << 8 + branchbyte2)
    const val if_icmpeq = 0x9f

    // 2: branchbyte1, branchbyte2
    // value1, value2 →
    // if value1 is greater than or equal to value2, branch to instruction at branchoffset (signed short constructed
    // from unsigned bytes branchbyte1 << 8 + branchbyte2)
    const val if_icmpge = 0xa2

    // 2: branchbyte1, branchbyte2
    // value1, value2 →
    // if value1 is greater than value2, branch to instruction at branchoffset (signed short constructed from unsigned
    // bytes branchbyte1 << 8 + branchbyte2)
    const val if_icmpgt = 0xa3

    // 2: branchbyte1, branchbyte2
    // value1, value2 →
    // if value1 is less than or equal to value2, branch to instruction at branchoffset (signed short constructed from
    // unsigned bytes branchbyte1 << 8 + branchbyte2)
    const val if_icmple = 0xa4

    // 2: branchbyte1, branchbyte2
    // value1, value2 →
    // if value1 is less than value2, branch to instruction at branchoffset (signed short constructed from unsigned
    // bytes branchbyte1 << 8 + branchbyte2)
    const val if_icmplt = 0xa1

    // 2: branchbyte1, branchbyte2
    // value1, value2 →
    // if ints are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes
    // branchbyte1 << 8 + branchbyte2)
    const val if_icmpne = 0xa0

    // 2: branchbyte1, branchbyte2
    // value →
    // if value is 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes
    // branchbyte1 << 8 + branchbyte2)
    const val ifeq = 0x99

    // 2: branchbyte1, branchbyte2
    // value →
    // if value is greater than or equal to 0, branch to instruction at branchoffset (signed short constructed from
    // unsigned bytes branchbyte1 << 8 + branchbyte2)
    const val ifge = 0x9c

    // 2: branchbyte1, branchbyte2
    // value →
    // if value is greater than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes
    // branchbyte1 << 8 + branchbyte2)
    const val ifgt = 0x9d

    // 2: branchbyte1, branchbyte2
    // value →
    // if value is less than or equal to 0, branch to instruction at branchoffset (signed short constructed from
    // unsigned bytes branchbyte1 << 8 + branchbyte2)
    const val ifle = 0x9e

    // 2: branchbyte1, branchbyte2
    // value →
    // if value is less than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes
    // branchbyte1 << 8 + branchbyte2)
    const val iflt = 0x9b

    // 2: branchbyte1, branchbyte2
    // value →
    // if value is not 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes
    // branchbyte1 << 8 + branchbyte2)
    const val ifne = 0x9a

    // 2: branchbyte1, branchbyte2
    // value →
    // if value is not null, branch to instruction at branchoffset (signed short constructed from unsigned bytes
    // branchbyte1 << 8 + branchbyte2)
    const val ifnonnull = 0xc7

    // 2: branchbyte1, branchbyte2
    // value →
    // if value is null, branch to instruction at branchoffset (signed short constructed from unsigned bytes
    // branchbyte1 << 8 + branchbyte2)
    const val ifnull = 0xc6

    // 2: index, const
    // [No change]
    // increment local variable #index by signed byte const
    const val iinc = 0x84

    // 1: index
    // → value
    // load an int value from a local variable #index
    const val iload = 0x15

    // → value
    // load an int value from local variable 0
    const val iload_0 = 0x1a

    // → value
    // load an int value from local variable 1
    const val iload_1 = 0x1b

    // → value
    // load an int value from local variable 2
    const val iload_2 = 0x1c

    // → value
    // load an int value from local variable 3
    const val iload_3 = 0x1d

    //
    // reserved for implementation-dependent operations within debuggers; should not appear in any class file
    const val impdep1 = 0xfe

    //
    // reserved for implementation-dependent operations within debuggers; should not appear in any class file
    const val impdep2 = 0xff

    // value1, value2 → result
    // multiply two integers
    const val imul = 0x68

    // value → result
    // negate int
    const val ineg = 0x74

    // 2: indexbyte1, indexbyte2
    // objectref → result
    // determines if an object objectref is of a given type, identified by class reference index in constant pool
    // (indexbyte1 << 8 + indexbyte2)
    const val instanceof = 0xc1

    // 4: indexbyte1, indexbyte2, 0, 0
    // [arg1, [arg2 ...]] → result
    // invokes a dynamic method and puts the result on the stack (might be void); the method is identified by method
    // reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    const val invokedynamic = 0xba

    // 4: indexbyte1, indexbyte2, count, 0
    // objectref, [arg1, arg2, ...] → result
    // invokes an interface method on object objectref and puts the result on the stack (might be void); the interface
    // method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    const val invokeinterface = 0xb9

    // 2: indexbyte1, indexbyte2
    // objectref, [arg1, arg2, ...] → result
    // invoke instance method on object objectref and puts the result on the stack (might be void); the method is
    // identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    const val invokespecial = 0xb7

    // 2: indexbyte1, indexbyte2
    // [arg1, arg2, ...] → result
    // invoke a static method and puts the result on the stack (might be void); the method is identified by method
    // reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    const val invokestatic = 0xb8

    // 2: indexbyte1, indexbyte2
    // objectref, [arg1, arg2, ...] → result
    // invoke virtual method on object objectref and puts the result on the stack (might be void); the method is
    // identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)
    const val invokevirtual = 0xb6

    // value1, value2 → result
    // bitwise int OR
    const val ior = 0x80

    // value1, value2 → result
    // logical int remainder
    const val irem = 0x70

    // value → [empty]
    // return an integer from a method
    const val ireturn = 0xac

    // value1, value2 → result
    // int shift left
    const val ishl = 0x78

    // value1, value2 → result
    // int arithmetic shift right
    const val ishr = 0x7a

    // 1: index
    // value →
    // store int value into variable #index
    const val istore = 0x36

    // value →
    // store int value into variable 0
    const val istore_0 = 0x3b

    // value →
    // store int value into variable 1
    const val istore_1 = 0x3c

    // value →
    // store int value into variable 2
    const val istore_2 = 0x3d

    // value →
    // store int value into variable 3
    const val istore_3 = 0x3e

    // value1, value2 → result
    // int subtract
    const val isub = 0x64

    // value1, value2 → result
    // int logical shift right
    const val iushr = 0x7c

    // value1, value2 → result
    // int xor
    const val ixor = 0x82

    // 2: branchbyte1, branchbyte2
    // → address
    // jump to subroutine at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)
    // and place the return address on the stack
    const val jsr = 0xa8

    // 4: branchbyte1, branchbyte2, branchbyte3, branchbyte4
    // → address
    // jump to subroutine at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 +
    // branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4) and place the return address on the stack
    const val jsr_w = 0xc9

    // value → result
    // convert a long to a double
    const val l2d = 0x8a

    // value → result
    // convert a long to a float
    const val l2f = 0x89

    // value → result
    // convert a long to a int
    const val l2i = 0x88

    // value1, value2 → result
    // add two longs
    const val ladd = 0x61

    // arrayref, index → value
    // load a long from an array
    const val laload = 0x2f

    // value1, value2 → result
    // bitwise AND of two longs
    const val land = 0x7f

    // arrayref, index, value →
    // store a long to an array
    const val lastore = 0x50

    // value1, value2 → result
    // push 0 if the two longs are the same, 1 if value1 is greater than value2, -1 otherwise
    const val lcmp = 0x94

    // → 0L
    // push 0L (the number zero with type long) onto the stack
    const val lconst_0 = 0x09

    // → 1L
    // push 1L (the number one with type long) onto the stack
    const val lconst_1 = 0x0a

    // 1: index
    // → value
    // push a constant #index from a constant pool (String, int, float, Class, java.lang.invoke.MethodType, or
    // java.lang.invoke.MethodHandle) onto the stack
    const val ldc = 0x12

    // 2: indexbyte1, indexbyte2
    // → value
    // push a constant #index from a constant pool (String, int, float, Class, java.lang.invoke.MethodType, or
    // java.lang.invoke.MethodHandle) onto the stack (wide index is constructed as indexbyte1 << 8 + indexbyte2)
    const val ldc_w = 0x13

    // 2: indexbyte1, indexbyte2
    // → value
    // push a constant #index from a constant pool (double or long) onto the stack (wide index is constructed as
    // indexbyte1 << 8 + indexbyte2)
    const val ldc2_w = 0x14

    // value1, value2 → result
    // divide two longs
    const val ldiv = 0x6d

    // 1: index
    // → value
    // load a long value from a local variable #index
    const val lload = 0x16

    // → value
    // load a long value from a local variable 0
    const val lload_0 = 0x1e

    // → value
    // load a long value from a local variable 1
    const val lload_1 = 0x1f

    // → value
    // load a long value from a local variable 2
    const val lload_2 = 0x20

    // → value
    // load a long value from a local variable 3
    const val lload_3 = 0x21

    // value1, value2 → result
    // multiply two longs
    const val lmul = 0x69

    // value → result
    // negate a long
    const val lneg = 0x75

    // 8+: <0–3 bytes padding>,
    // defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4,
    // npairs1, npairs2, npairs3, npairs4,
    // match-offset pairs...
    // key →
    // a target address is looked up from a table using a key and execution continues from the instruction at that
    // address
    const val lookupswitch = 0xab

    // value1, value2 → result
    // bitwise OR of two longs
    const val lor = 0x81

    // value1, value2 → result
    // remainder of division of two longs
    const val lrem = 0x71

    // value → [empty]
    // return a long value
    const val lreturn = 0xad

    // value1, value2 → result
    // bitwise shift left of a long value1 by int value2 positions
    const val lshl = 0x79

    // value1, value2 → result
    // bitwise shift right of a long value1 by int value2 positions
    const val lshr = 0x7b

    // 1: index
    // value →
    // store a long value in a local variable #index
    const val lstore = 0x37

    // value →
    // store a long value in a local variable 0
    const val lstore_0 = 0x3f

    // value →
    // store a long value in a local variable 1
    const val lstore_1 = 0x40

    // value →
    // store a long value in a local variable 2
    const val lstore_2 = 0x41

    // value →
    // store a long value in a local variable 3
    const val lstore_3 = 0x42

    // value1, value2 → result
    // subtract two longs
    const val lsub = 0x65

    // value1, value2 → result
    // bitwise shift right of a long value1 by int value2 positions, unsigned
    const val lushr = 0x7d

    // value1, value2 → result
    // bitwise XOR of two longs
    const val lxor = 0x83

    // objectref →
    // enter monitor for object ("grab the lock" – start of synchronized() section)
    const val monitorenter = 0xc2

    // objectref →
    // exit monitor for object ("release the lock" – end of synchronized() section)
    const val monitorexit = 0xc3

    // 3: indexbyte1, indexbyte2, dimensions
    // count1, [count2,...] → arrayref
    // create a new array of dimensions dimensions of type identified by class reference in constant pool index
    // (indexbyte1 << 8 + indexbyte2); the sizes of each dimension is identified by count1, [count2, etc.]
    const val multianewarray = 0xc5

    // 2: indexbyte1, indexbyte2
    // → objectref
    // create new object of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2)
    const val new = 0xbb

    // 1: atype
    // count → arrayref
    // create new array with count elements of primitive type identified by atype
    const val newarray = 0xbc

    // [No change]
    // perform no operation
    const val nop = 0x00

    // value →
    // discard the top value on the stack
    const val pop = 0x57

    // {value2, value1} →
    // discard the top two values on the stack (or one value, if it is a double or long)
    const val pop2 = 0x58

    // 2: indexbyte1, indexbyte2
    // objectref, value →
    // set field to value in an object objectref, where the field is identified by a field reference index in constant
    // pool (indexbyte1 << 8 + indexbyte2)
    const val putfield = 0xb5

    // 2: indexbyte1, indexbyte2
    // value →
    // set static field to value in a class, where the field is identified by a field reference index in constant pool
    // (indexbyte1 << 8 + indexbyte2)
    const val putstatic = 0xb3

    // 1: index
    // [No change]
    // continue execution from address taken from a local variable #index (the asymmetry with jsr is intentional)
    const val ret = 0xa9

    // → [empty]
    // return void from method
    const val `return` = 0xb1

    // arrayref, index → value
    // load short from array
    const val saload = 0x35

    // arrayref, index, value →
    // store short to array
    const val sastore = 0x56

    // 2: byte1, byte2
    // → value
    // push a short onto the stack as an integer value
    const val sipush = 0x11

    // value2, value1 → value1, value2
    // swaps two top words on the stack (note that value1 and value2 must not be double or long)
    const val swap = 0x5f

    // 16+: [0–3 bytes padding],
    // defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4,
    // lowbyte1, lowbyte2, lowbyte3, lowbyte4,
    // highbyte1, highbyte2, highbyte3, highbyte4,
    // jump offsets...
    // index →
    // continue execution from an address in the table at offset index
    const val tableswitch = 0xaa

    // 3/5: opcode, indexbyte1, indexbyte2or iinc, indexbyte1, indexbyte2, countbyte1, countbyte2
    // [same as for corresponding instructions]
    // execute opcode, where opcode is either iload, fload, aload, lload, dload, istore, fstore, astore, lstore, dstore,
    // or ret, but assume the index is 16 bit; or execute iinc, where the index is 16 bits and the constant to increment
    // by is a signed 16 bit short
    const val wide = 0xc4

    //
    // these values are currently unassigned for opcodes and are reserved for future use
//    const val (no name) = 0xcb-fd

}